/*************************************************************************
| SalernOS Kernel                                                        |
| Copyright (C) 2021 - 2026 Alessandro Salerno                           |
|                                                                        |
| This program is free software: you can redistribute it and/or modify   |
| it under the terms of the GNU General Public License as published by   |
| the Free Software Foundation, either version 3 of the License, or      |
| (at your option) any later version.                                    |
|                                                                        |
| This program is distributed in the hope that it will be useful,        |
| but WITHOUT ANY WARRANTY; without even the implied warranty of         |
| MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the          |
| GNU General Public License for more details.                           |
|                                                                        |
| You should have received a copy of the GNU General Public License      |
| along with this program.  If not, see <https://www.gnu.org/licenses/>. |
*************************************************************************/

#include <arch/context.h>
#include <arch/cpu.h>
#include <arch/info.h>
#include <kernel/com/dev/gfx/fbdev.h>
#include <kernel/com/dev/null.h>
#include <kernel/com/dev/profile.h>
#include <kernel/com/fs/devfs.h>
#include <kernel/com/fs/file.h>
#include <kernel/com/fs/initrd.h>
#include <kernel/com/fs/tmpfs.h>
#include <kernel/com/fs/vfs.h>
#include <kernel/com/init.h>
#include <kernel/com/io/console.h>
#include <kernel/com/io/log.h>
#include <kernel/com/io/pty.h>
#include <kernel/com/io/term.h>
#include <kernel/com/io/tty.h>
#include <kernel/com/ipc/signal.h>
#include <kernel/com/mm/pmm.h>
#include <kernel/com/mm/slab.h>
#include <kernel/com/mm/vmm.h>
#include <kernel/com/sys/callout.h>
#include <kernel/com/sys/elf.h>
#include <kernel/com/sys/proc.h>
#include <kernel/com/sys/profiler.h>
#include <kernel/com/sys/sched.h>
#include <kernel/com/sys/syscall.h>
#include <kernel/com/sys/thread.h>
#include <kernel/opt/flanterm.h>
#include <kernel/platform/context.h>
#include <kernel/platform/info.h>
#include <kernel/platform/mmu.h>
#include <lib/str.h>
#include <lib/util.h>
#include <stdint.h>
#include <stdio.h>

// These do not follow naming conventions because they're generated by LD
extern const char _binary_src_splash_txt_start[];
extern const char _binary_src_splash_txt_end[];

// These are set at the END of the respective init functions and are meant to be
// used by other init functions
static com_term_t  *MainTerm   = NULL;
static com_vnode_t *MainTtyDev = NULL;
static com_vfs_t   *RootFs     = NULL;

static com_vfs_t *init_tmpfs(com_vfs_t *rootfs) {
    com_vnode_t *tmpfs_mountpoint = NULL;
    com_vfs_t   *tmpfs            = NULL;
    com_fs_tmpfs_mkdir(&tmpfs_mountpoint,
                       rootfs->root,
                       "tmp",
                       kstrlen("tmp"),
                       0,
                       0);
    com_fs_tmpfs_mount(&tmpfs, tmpfs_mountpoint);
    return tmpfs;
}

static com_vfs_t *init_procfs(com_vfs_t *rootfs) {
    com_vnode_t *procfs_mountpoint = NULL;
    com_vfs_t   *procfs            = NULL;
    com_fs_tmpfs_mkdir(&procfs_mountpoint,
                       rootfs->root,
                       "proc",
                       kstrlen("proc"),
                       0,
                       0);
    com_fs_tmpfs_mount(&procfs, procfs_mountpoint);
    return procfs;
}

void com_init_splash(void) {
#if CONFIG_LOG_SHOW_SPLASH
    com_io_log_putsn(_binary_src_splash_txt_start,
                     _binary_src_splash_txt_end - _binary_src_splash_txt_start);
    com_io_log_puts("\n\n");
#endif
}

void com_init_memory(void) {
    com_mm_pmm_init();
    arch_mmu_init();
    com_mm_vmm_init();
}

void com_init_filesystem(void) {
    com_vfs_t *rootfs = NULL;
    com_fs_tmpfs_mount(&rootfs, NULL);

    init_tmpfs(rootfs);
    com_vfs_t *procfs = init_procfs(rootfs);

#if CONFIG_LOG_USE_VNODE
    com_vnode_t *proc_kernel = NULL;
    com_fs_tmpfs_mkdir(&proc_kernel,
                       procfs->root,
                       "kernel",
                       kstrlen("kernel"),
                       0,
                       0);

#warning "log to vnode is experimental!"
    com_vnode_t *kernel_log = NULL;
    com_fs_tmpfs_create(&kernel_log, proc_kernel, "log", kstrlen("log"), 0, 0);
    com_io_log_set_vnode(kernel_log);
#endif

    arch_file_t *initrd = arch_info_get_initrd();
    com_fs_initrd_make(rootfs->root, initrd->address, initrd->size);

    com_vfs_t *devfs = NULL;
    com_fs_devfs_init(&devfs, rootfs);

    RootFs = rootfs;
}

void com_init_tty(com_term_backend_t (*new_backend)(void)) {
    com_vnode_t *devtty = NULL;
    com_io_tty_devtty_init(&devtty);

#if CONFIG_TTY_MAX < 1
#error "cannot compile the kernel with less than 1 TTY"
#endif

    com_term_backend_t main_tb   = new_backend();
    com_term_t        *main_term = com_io_term_new(main_tb);
    com_io_term_set_fallback(main_term);

    com_vnode_t *main_tty_dev  = NULL;
    com_tty_t   *main_tty_data = NULL;
    com_io_tty_init_text(&main_tty_dev, &main_tty_data, main_term);
    com_io_term_init();
    com_io_console_add_tty(main_tty_data);

    for (size_t i = 0; i < CONFIG_TTY_MAX - 1; i++) {
        com_term_backend_t tb   = new_backend();
        com_term_t        *term = com_io_term_new(tb);

        com_vnode_t *tty_dev  = NULL;
        com_tty_t   *tty_data = NULL;
        com_io_tty_init_text(&tty_dev, &tty_data, term);
        com_io_term_set_buffering(term, true);
        com_io_console_add_tty(tty_data);
    }

    com_io_pty_init();
    MainTerm   = main_term;
    MainTtyDev = main_tty_dev;
}

void com_init_devices(void) {
    com_dev_gfx_fbdev_init(NULL);
    com_dev_null_init();
    com_dev_profile_init();
}

void com_init_pid1(void) {
    com_sys_proc_init();

    KASSERT(NULL != RootFs);
    char *const   argv[] = {CONFIG_INIT_PATH, CONFIG_INIT_ARGV};
    char *const   envp[] = {CONFIG_INIT_ENV};
    com_proc_t   *proc = com_sys_proc_new(NULL, 0, RootFs->root, RootFs->root);
    com_thread_t *thread  = com_sys_thread_new(proc, NULL, 0, NULL);
    int           elf_ret = com_sys_elf64_prepare_proc(&proc->vmm_context,
                                             CONFIG_INIT_PATH,
                                             argv,
                                             envp,
                                             proc,
                                             &thread->ctx);

    if (0 != elf_ret) {
        com_sys_panic(NULL,
                      "unable to start init program at %s",
                      CONFIG_INIT_PATH);
    }

    KASSERT(NULL != MainTtyDev);
    com_file_t *stdfile = com_mm_slab_alloc(sizeof(com_file_t));
    stdfile->vnode      = MainTtyDev;
    stdfile->num_ref    = 3;
    proc->next_fd       = 3;
    com_filedesc_t stddesc;
    stddesc.file  = stdfile;
    stddesc.flags = 0;
    proc->fd[0]   = stddesc;
    proc->fd[1]   = stddesc;
    proc->fd[2]   = stddesc;

    com_sys_proc_new_session_nolock(proc, MainTtyDev);

    arch_cpu_t *curr_cpu = ARCH_CPU_GET();
    KASSERT(NULL != curr_cpu);
    ARCH_CPU_SET_INTERRUPT_STACK(curr_cpu, thread->kernel_stack);
    curr_cpu->thread = thread;

    KASSERT(NULL != proc);
    KASSERT(NULL != proc->vmm_context);
    com_mm_vmm_switch(proc->vmm_context);
    ARCH_CONTEXT_RESTORE_EXTRA(thread->xctx);

    com_mm_vmm_init_reaper();
    com_mm_pmm_init_threads();

    KASSERT(NULL != MainTerm);
    com_io_log_set_user_hook(NULL);
    com_io_term_enable(MainTerm);
    com_io_term_set_buffering(MainTerm, true);
    com_io_log_set_vnode(NULL);
    com_sys_profiler_init();
    arch_context_trampoline(&thread->ctx);
}
